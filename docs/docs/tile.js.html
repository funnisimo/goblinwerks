<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: tile.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: tile.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
import * as Game from './game.js';
import * as Text from './text.js';
import * as Flags from './flags.js';
import * as Utils from './utils.js';
import { types, def, make, data as DATA, flag as FLAG, tiles, colors as COLORS } from './gw.js';

export var tile = {};

const TileLayer = def.layer;

/** Tile Class */
export class Tile {
  /**
    * Creates a new Tile object.
    * @param {Object} [config={}] - The configuration of the Tile
    * @param {String|Number|String[]} [config.flags=0] - Flags and MechFlags for the tile
    * @param {String} [config.layer=GROUND] - Name of the layer for this tile
    * @param {String} [config.ch] - The sprite character
    * @param {String} [config.fg] - The sprite foreground color
    * @param {String} [config.bg] - The sprite background color
    */
  constructor(config={}, base={}) {
    Object.assign(this, {
      flags: 0,
      mechFlags: 0,
      layer: 0,
      priority: -1,
      sprite: make.sprite(),
      events: {},
      light: null,  // id of light for this tile
      flavor: null,
      name: '',
      article: 'a',
      id: null,
      dissipate: 2000, // 20% of 10000
    });
    Utils.assignOmitting(['events'], this, base);
    Utils.assignOmitting(['Extends', 'flags', 'mechFlags', 'sprite', 'events'], this, config);
    if (this.priority &lt; 0) {
      this.priority = 50;
    }
    this.layer = TileLayer[this.layer] || this.layer;
    this.flags = Flags.Tile.toFlag(this.flags, config.flags);
    this.mechFlags = Flags.TileMech.toFlag(this.mechFlags, config.mechFlags || config.flags);

    if (config.sprite || (config.ch || config.fg || config.bg)) {
      this.sprite = make.sprite(config.sprite || config);
    }
    if (base.events) {
      Object.assign(this.events, base.events);
    }
    if (config.events) {
      Object.entries(config.events).forEach( ([key,info]) => {
        if (info) {
          this.events[key] = make.tileEvent(info);
        }
        else {
          delete this.events[key];
        }
      });
    }
  }

  /**
   * Returns the flags for the tile after the given event is fired.
   * @param {String} event - Name of the event to fire.
   * @returns {Number} The flags from the Tile after the event.
   */
  successorFlags(event) {
    const e = this.events[event];
    if (!e) return 0;
    const feature = e.feature;
    if (!feature) return 0;
    // const tile = FEATURES[feature].tile;
    // if (!tile) return 0;
    // return tiles[tile].flags;
  }

  /**
   * Returns whether or not this tile as the given flag.
   * Will return true if any bit in the flag is true, so testing with
   * multiple flags will return true if any of them is set.
   * @param {Number} flag - The flag to check
   * @returns {Boolean} Whether or not the flag is set
   */
  hasFlag(flag) {
    return (this.flags &amp; flag) > 0;
  }

  hasFlags(flags, mechFlags) {
    return (!flags || (this.flags &amp; flags)) &amp;&amp; (!mechFlags || (this.mechFlags &amp; mechFlags));
  }

  hasMechFlag(flag) {
    return (this.mechFlags &amp; flag) > 0;
  }

  hasEvent(name) {
    return !!this.events[name];
  }

  getName(opts={}) {
    if (opts === true) { opts = { article: true }; }
    if (opts === false) { opts = {}; }
    if (typeof opts === 'string') { opts = { article: opts }; }

    if (!opts.article &amp;&amp; !opts.color) return this.name;

    let result = this.name;
    if (opts.color) {
      let color = this.sprite.fg;
      if (opts.color instanceof types.Color) {
        color = opts.color;
      }
      result = Text.apply('#color#$name$##', { color, name: this.name });
    }

    if (opts.article &amp;&amp; this.article) {
      let article = (opts.article === true) ? this.article : opts.article;
      result = article + ' ' + result;
    }
    return result;
  }
  getDescription(opts={}) { return this.getName(opts); }

  getFlavor() { return this.flavor || this.getName(true); }


  async applyInstantEffects(map, x, y, cell) {

    const actor = cell.actor;
    const isPlayer = actor ? actor.isPlayer() : false;

    if (this.flags &amp; Flags.Tile.T_LAVA &amp;&amp; actor) {
      if (!cell.hasTileFlag(Flags.Tile.T_BRIDGE) &amp;&amp; !actor.status.levitating) {
        actor.kind.kill(actor);
        await Game.gameOver(false, '#red#you fall into lava and perish.');
        return true;
      }
    }

    return false;
  }

}

types.Tile = Tile;

/**
 * GW.tile
 * @module tile
 */


/**
 * Adds a new Tile into the GW.tiles collection.
 * @param {String} id - The identifier for this Tile
 * @param {Object} [base] - The base tile from which to extend
 * @param {Object} config - The tile parameters
 * @returns {Tile} The newly created tile
 */
export function addTileKind(id, base, config) {
  if (arguments.length == 1) {
    config = args[0];
    base = config.Extends || {};
    id = config.id || config.name;
  }
  else if (arguments.length == 2) {
    config = base;
    base = config.Extends || {};
  }

  if (typeof base === 'string') {
    base = tiles[base] || Utils.ERROR('Unknown base tile: ' + base);
  }

  config.name = config.name || id.toLowerCase();
  config.id = id;
  const tile = new types.Tile(config, base);
  tiles[id] = tile;
  return tile;
}

tile.addKind = addTileKind;

/**
 * Adds multiple tiles to the GW.tiles collection.
 * It extracts all the id:opts pairs from the config object and uses
 * them to call addTileKind.
 * @param {Object} config - The tiles to add in [id, opts] pairs
 * @returns {void} Nothing
 * @see addTileKind
 */
export function addTileKinds(config={}) {
  Object.entries(config).forEach( ([name, opts]) => {
    tile.addKind(name, opts);
  });
}

tile.addKinds = addTileKinds;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-tile.html">tile</a></li><li><a href="module-utils.html">utils</a></li></ul><h3>Classes</h3><ul><li><a href="Listener.html">Listener</a></li><li><a href="Tile.html">Tile</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addListener">addListener</a></li><li><a href="global.html#clearEvent">clearEvent</a></li><li><a href="global.html#emit">emit</a></li><li><a href="global.html#off">off</a></li><li><a href="global.html#on">on</a></li><li><a href="global.html#once">once</a></li><li><a href="global.html#removeAllListeners">removeAllListeners</a></li><li><a href="global.html#removeListener">removeListener</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Tue Nov 17 2020 14:27:29 GMT-0600 (Central Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
